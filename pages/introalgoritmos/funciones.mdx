# Funciones 

> Una función es una regla que asigna a cada elemento
de un primer conjunto un único elemento de un segundo conjunto.

Diremos que una **función** le “asigna” a los elementos de un conjunto, llamado **dominio**, elementos de otro
conjunto, llamado **codominio**. La notación:

```math
f : A → B
```

Indica que $$f$$ es una función con dominio $$A$$ y codominio $$B$$. La definición de una función tiene la forma:

$$f.x$$ = ⟨expresión que depende de x⟩ donde $$f$$ es el nombre de la función $$y$$ $$x$$ es/son la/s variable/s independiente/s.

***

En las siguientes definiciones identificaremos las variables, las constantes y el
nombre de la función.

```math
f.x = 5 ∗ x 
```

• Variable: x

• Constante: 5

• Nombre de la función: $$f$$

***

```math
multiplicar.zz.tt = zz ∗ tt
```
• Variables: zz, tt

• Constantes: Ninguna

• Nombre de la función: multiplicar

***

```math
duplica.a = a + a
```

• Variable: a 

• Constante: No hay constantes explícitas en esta expresión

• Nombre de la función: duplica

***

Tomando las definiciones del punto anterior evaluemos las siguientes expresiones. Justificaremos cada paso utilizando la
notación aprendida. 

(multiplicar . (f . 5 ) . 2) + 1

≡ ```{``` Definición de f ```}```

(multiplicar . (5 ∗ 5) . 2) + 1

≡ ```{``` Definición de multiplicar ```}```

(5 ∗ 5) ∗ 2 + 1

≡ ```{``` Aritmética ```}```

≡ (25 ∗ 2) + 1

≡ ```{``` Aritmética ```}```

≡ 50 + 1

≡ ```{``` Aritmética ```}```

≡ 51

***

## Tipado de funciones

> El **tipado de funciones** es una forma de especificar el tipo de datos que una función acepta como entrada y el tipo de datos que devuelve como salida.

Tomemos la función $$g$$

```math
g.x.y ≐ 3*x − x * y > 0
```

Esta función toma dos argumentos de tipo Num y devuelve un valor de tipo Bool. Así, el tipo
de g se declara de la siguiente forma:

```math
g : Num → Num → Bool
```
Es decir, los tipos de los argumentos se listan primero, siguiendo el orden en el que serán
llamados por la función, y en último lugar se coloca el tipo del resultado de evaluar la
función.

*** 

A continuación daremos el **tipo** de las siguientes funciones:

**A)**$$ㅤg.y ≐ 8 * y$$

$$g :: Numㅤ a ⇒ a $$

• Toma un argumento de tipo Num y devuelve un valor de tipo Num.

***

**B)**$$ㅤh.z.w ≐ z + w$$

$$h :: Numㅤ a ⇒ a → a → a$$

• Toma dos argumentos de tipo Num y devuelve un valor de tipo Num.

***

**C)**$$ㅤj.x ≐ x ≤ 0$$

$$j :: Numㅤ a ⇒ a → Bool$$

• Toma un argumento de tipo Num y devuelve un valor de tipo Bool.

***

## Definiciones de Funciones por casos 

> Las **definiciones de funciones por casos** son una forma de definir funciones que toman diferentes valores dependiendo de los valores de sus argumentos.

Hay ocasiones en las que una sola fórmula no alcanza para definir una función. Así, existen
funciones que para una parte del dominio requieren una definición y para otra parte del
dominio necesitan de otra definición diferente. Es el caso, por ejemplo, de la función valor
absoluto que dado un número devuelve su valor absoluto.

Una definición por casos de una función tendrá la siguiente forma general:

```hs
f.x ≐ ( B0 → f0

□ B1 → f1

...

□ Bn → fn

)
```

Donde las Bi son expresiones de tipo booleano, llamadas guardas, y las fi son expresiones
del mismo tipo que el resultado de f que nos describe algebraicamente la relación para cada
caso. Para un argumento dado el valor de la función se corresponde con la expresión cuya
guarda es verdadera para ese argumento.
Al trabajar con expresiones booleanas se hace necesario incorporar a nuestro formalismo los operadores
$$∧$$, $$∨$$, $$¬$$ que pueden ser utilizados para combinar dos fórmulas para obtener una nueva fórmula. En haskell estos
operadores se escriben $$&&$$ , $$||$$ y $$not$$, respectivamente.

***

Definí las funciones que describimos a continuación, luego implementalas en haskell . Por ejemplo:
Enunciado: $$signo : Int → Int$$, que dado un entero retorna su signo, de la siguiente forma: retorna $$1$$ si
$$x$$ es positivo, $$-1$$ si es negativo y 0 en cualquier otro caso.

Solución:
    
```hs
signo.x ≐ ( x > 0 → 1
□ x < 0 → -1
□ x = 0 → 0
)
```

Esta definición, en haskell se anota de la siguiente manera

```hs
signo :: Int -> Int
signo x | x > 0 = 1
        | x < 0 = -1
        | x == 0 = 0
```
***

**a)** $$entre0y9 : Int → Bool$$, que dado un entero devuelve $$True$$ si el entero se encuentra entre $$0$$ y $$9$$.

```hs
entre0y9 :: Int -> Bool
entre0y9 x = x >= 0 && x <= 9 
```
No hace falta aclarar que si el número está dentro del conjunto es $$true$$ y si no $$false$$ ya que haskell lo entiende por defecto.

***

**b)** $$rangoPrecio : Int → String$$, que dado un número que representa el precio de una
computadora, retorne “muy barato” si el precio es menor a $$2000$$, “demasiado caro” si el
precio es mayor que $$5000$$, “hay que verlo bien” si el precio está entre $$2000$$ y $$5000$$, y “esto
no puede ser!” si el precio es negativo.

```hs
rangoPrecio :: Int -> String
rangoPrecio  x | x < 2000 && x > 0 = "muy barato"
               | x > 5000 = "demasiado caro"
               | 2000 <= x && x <= 5000 = "hay que verlo bien"
               | x < 0 = "esto no puede ser!"
```
Muy importante aclarar que el precio no puede ser negativo, por lo que se pone la condición $$x < 0$$.

***

**c)** $$absoluto : Int → Int$$, que dado un entero retorne su valor absoluto.

```hs
absoluto :: Int -> Int
absoluto x | x >= 0 = x
           | x < 0 = -x
```
En este caso, si el número es positivo, se devuelve el mismo número, y si es negativo, se devuelve el número multiplicado por $$-1$$.

***

**d)** $$esMultiplo2 : Int → Bool$$, que dado un entero n devuelve $$True$$ si $$n$$ es múltiplo de $$2$$.

```hs
esMultiplo2 :: Int -> Bool
esMultiplo2 x = mod x 2 == 0
```
En este caso, si el número es divisible por $$2$$, se devuelve $$True$$, y si no, $$False$$.

***

## Combinando Funciones

> El **Combinado de funciones** es una operación que toma dos funciones y las combina para formar una nueva función.

En algunos ejercicios que siguen se van a utilizar algunas de las funciones que están en el
Prelude (librería básica de Haskell). Por ejemplo:

$$mod$$ $$20$$ $$3$$ = $$2$$ – el resto de la división entre $$20$$ y $$3$$ es $$2$$.

$$div$$ $$14$$ $$3$$ = $$4$$ – parte entera de la división entre $$14$$ y $$3$$ es $$4$$.

$$max$$ $$8$$ $$10$$ = $$10$$ – devuelve el max entre $$2$$ números.

$$min$$ $$9$$ $$15$$ = $$9$$ – devuelve el min entre $$2$$ números.

Definí la función $$esMultiploDe : Num→ Num→ Bool$$ , que devuelve $$True$$ si el
segundo es múltiplo del primero. Ejemplo: $$esMultiploDe$$ $$3$$ $$1$$2 = $$True$$.

```hs
esMultiploDe :: Int -> Int -> Bool
esMultiploDe x y = (mod y x) == 0
```

En este caso, si el segundo número es divisible por el primero, se devuelve $$True$$, y si no, $$False$$.

***

Definí la función $$esBisiesto: Num→ Bool$$ , que indica si un año es bisiesto. Un
año es bisiesto si es divisible por $$400$$ o es divisible por 4 pero no es divisible por $$100$$.

```hs
esBisiesto :: Int -> Bool
esBisiesto x = (mod x 400 == 0) || (mod x 4 == 0 && mod x 100 /= 0)
```

En este caso, si el año es divisible por $$400$$ o por $$4$$ pero no por $$100$$, se devuelve $$True$$, y si no, $$False$$.

***

Definí la función $$dispersion : Num→ Num→ Num→ Num$$, que toma los tres
valores y devuelve la diferencia entre el más alto y el más bajo. Ayuda: extender max y min
a tres argumentos, usando las versiones de dos elementos. De esa forma se puede definir
dispersión sin escribir ninguna guarda (las guardas están en max y min, que estamos
usando).

```hs
dispersion :: Int -> Int -> Int -> Int
dispersion x y z = max x (max y z) - min x (min y z)
```

En este caso, se devuelve la diferencia entre el número más alto y el más bajo.

***

Definí la función $$celsiusToFahr : Num→ Num$$, pasa una temperatura en
grados Celsius a grados Fahrenheit. Para realizar la conversión hay que multiplicar por $$1.8$$ y
sumar $$32$$.

```hs
celsiusToFahr :: Float -> Float
celsiusToFahr x = x * 1.8 + 32
```

En este caso, se multiplica la temperatura en grados Celsius por $$1.8$$ y se le suma $$32$$ para obtener la temperatura en grados Fahrenheit.

***

Definí la función $$fahrToCelsius : Num→ Num$$, la inversa de la anterior. Para
realizar la conversión hay que primero restar $$32$$ y después dividir por $$1.8$$.

```hs
fahrToCelsius :: Float -> Float
fahrToCelsius x = (x - 32) / 1.8
```

En este caso, se resta $$32$$ a la temperatura en grados Fahrenheit y se divide por $$1.8$$ para obtener la temperatura en grados Celsius.

***

Definí la función $$haceFrioF : Num→ Bool$$ , indica si una temperatura
expresada en grados Fahrenheit es fría. Decimos que hace frío si la temperatura es menor
a $$8$$ grados Celsius.

```hs
haceFrioF :: Float -> Bool
haceFrioF x = fahrToCelsius x < 8
```

En este caso, si la temperatura en grados Fahrenheit es menor a $$8$$ grados Celsius, se devuelve $$True$$, y si no, $$False$$.

***

## Tuplas

> Una **Tupla** es una secuencia de elementos de longitud fija. Cada elemento de una tupla puede ser de un tipo diferente.

Una manera de formar un nuevo tipo es combinando los otros ya existentes en tuplas (i.e.,
haciendo su producto cartesiano). El ejemplo más conocido es, quizás, el de un par de
números como $$(3,2)$$. $$(3,2)$$ es un elemento de tipo $$(Num, Num)$$. Por ejemplo, podemos
definir una función que toma dos pares y los suma coordenada a coordenada de la siguiente
forma

```hs
sumaPares : (Num,Num) → (Num,Num) → (Num,Num)
sumaPares.(a, b).(c, d) ≐ (a+c, b+d)
```

***

Definí las funciones que describimos a continuación, luego implementalas en
Haskell.

**a)** $$segundo3 : (Num, Num, Num) → Num$$, que dada una terna de enteros devuelve su
segundo elemento.

```hs
segundo3 :: (Int, Int, Int) -> Int
segundo3 (x, y, z) = y
```

En este caso, se devuelve el segundo elemento de la terna.

***

**b)** $$ordena : (Num, Num) → (Num, Num)$$, que dados dos enteros los ordena de menor a
mayor.

```hs
ordena :: (Int, Int) -> (Int, Int)
ordena (x, y) = (min x y, max x y)
```
 
En este caso, se devuelve una tupla con el menor número en la primera posición y el mayor en la segunda.

***

**c)** $$rangoPrecioParametrizado : Num → (Num, Num) → String$$ que dado un número $$x$$, que
representa el precio de un producto, y un par (menor, mayor) que represente el rango de
precios que uno espera encontrar, retorne “muy barato” si $$x$$ está por debajo del rango,
“demasiado caro” si está por arriba del rango, “hay que verlo bien” si el precio está en el
rango, y “esto no puede ser!” si x es negativo.

```hs
rangoPrecioParametrizado :: Int -> (Int, Int) -> String
rangoPrecioParametrizado x (y, z) | x < y && x > 0 = "muy barato"
                                  | x > z = "demasiado caro"
                                  | y <= x && x <= z = "hay que verlo bien"
                                  | x < 0 = "esto no puede ser!"
```

En este caso, si el precio está por debajo del rango, se devuelve “muy barato”, si está por arriba, “demasiado caro”, si está en el rango, 
“hay que verlo bien”, y si es negativo, “esto no puede ser!”.

***

**d)** $$mayor3 : (Num, Num, Num) → (Bool , Bool , Bool )$$, que dada una una terna de enteros
devuelve una terna de valores booleanos que indica si cada uno de los enteros es mayor
que $$3$$.

```hs
mayor3 :: (Int, Int, Int) -> (Bool, Bool, Bool)
mayor3 (x, y, z) = (x > 3, y > 3, z > 3)
```

En este caso, se devuelve una terna de valores booleanos que indica si cada uno de los enteros es mayor que $$3$$.

***

**e)** $$todosIguales : (Num, Num, Num) → Bool$$ que dada una terna de enteros devuelva $$True$$ si
todos sus elementos son iguales y $$False$$ en caso contrario.

```hs
todosIguales :: (Int, Int, Int) -> Bool
todosIguales (x, y, z) = x == y && y == z
``` 

En este caso, si todos los elementos de la terna son iguales, se devuelve $$True$$, y si no, $$False$$.

***

**f)** $$notaPromedio : (String, Num, Num, Num) → Num$$ que dada una tupla que representa el
nombre de un/a estudiante y las notas que sacó en cada parcial, calcule la nota promedio.

```hs
notaPromedio :: (String, Int, Int, Int) -> Int
notaPromedio (nombre, x, y, z) = div (x + y + z) 3
```

En este caso, se devuelve la nota promedio de un/a estudiante.

***

**g)** $$condicionFinal : (String, Num, Num, Num) → String$$ que dada una tupla que representa el
nombre de un/a estudiante y las notas que sacó en cada parcial, devuelva “promoción” si
las 3 notas son mayores a 7, “regular” si no promociona pero las 3 notas son mayores a 4, y
“libre” en caso contrario.

```hs
condicionFinal :: (String, Int, Int, Int) -> String
condicionFinal (nombre, x, y, z) | x >= 7 && y >= 7 && z >= 7 = "promoción"
                                 | x >= 4 && y >= 4 && z >= 4 = "regular"
                                 |  x <= 3 || y <= 3 || z <= 3 = "libre"
```

En este caso, si las 3 notas son mayores a $$7$$, se devuelve “promoción”, si no promociona pero las 3 notas son mayores a $$4$$, “regular”, y si no, “libre”.

***

## Listas

> Una **Lista** es una secuencia de elementos de longitud variable. Cada elemento de una lista puede ser de un tipo diferente.

Ahora, comenzaremos a complejizar el lenguaje de nuestras expresiones agregando listas.
Una lista (o secuencia) es una colección ordenada de valores, que deben ser todos del
mismo tipo; por ejemplo, [$$1, 2, 5$$].

Denotamos a la lista vacía con [ ]. El operador ▹ (llamado “pegar” y notado “$$:$$” en Haskell)
es fundamental (se lo denomina constructor), ya que permite construir listas arbitrarias a
partir de la lista vacía. ▹ toma un elemento $$x$$ (a izquierda) y una lista xs y devuelve una lista
con primer elemento x seguido de los elementos de $$xs$$. Por ejemplo:

```hs
3 ▹ [ ] = [3]
1 ▹ [2, 3] = [1, 2, 3]
```

Para denotar listas no vacías utilizamos expresiones de la forma [x, y, . . . , z], que son
abreviaciones de x ▹ (y ▹ . . . (z ▹ [ ]).

El operador ▹ es asociativo a derecha, por lo tanto, es lo mismo escribir x ▹ (y ▹ . . . (z ▹ [ ])
que x ▹ y ▹ . . . z ▹ [ ]. Otros operadores sobre listas son los siguientes:

● #, llamado **cardinal**, toma una lista xs y devuelve su cantidad de elementos. Ej:

```hs
#[1, 2, 0, 5] = 4
```

En Haskell #xs se escribe length xs.
 
● ! toma una lista xs (a izquierda) y un natural n que indica una posición, y devuelve el
elemento de la lista que se encuentra en la posición n (contando a partir de la
posición 0). Ej:

```hs
[1, 3, 3, 6, 2, 3, 4, 5] ! 4 = 2.
```

Este operador, llamado **índice**, asocia a izquierda, por lo tanto xs ! n ! m se
interpreta como (xs ! n) ! m.
En Haskell xs ! n se escribe xs !! n.

● ↑ toma una lista xs (a izquierda) y un natural n que indica una cantidad, y devuelve
la sublista con los primeros n elementos de xs. Ej:

```hs
[1, 2, 3, 4, 5, 6] ↑ 2 = [1, 2]
```

Este operador, llamado **tomar**, asocia a izquierda, por lo tanto xs ↑ n ↑ m se
interpreta como (xs ↑ n) ↑ m. En Haskell xs ↑ n se escribe: take n xs.

● ↓ toma una lista xs (a izquierda) y un natural n que indica una cantidad, y devuelve
la sublista sin los primeros n elementos de xs. Ej:

```hs
[1, 2, 3, 4, 5, 6] ↓ 2 = [3, 4, 5, 6]
```

Este operador, llamado **tirar**, se comporta igual al anterior, interpretando xs ↓ n ↓ m
como (xs ↓ n) ↓ m. En Haskell xs ↓ n se escribe: drop n xs.

● ⧺ toma una lista xs (a izquierda) y otra ys, y devuelve la lista con todos los elementos
de xs seguidos de los elementos de ys. Ej:

```hs
[1, 2, 4] ⧺ [1, 0, 7] = [1, 2, 4, 1, 0, 7]
```

Este operador, llamado **concatenar**, es asociativo por lo que podemos escribir sin
ambigüedad expresiones sin paréntesis, como xs ⧺ ys ⧺ zs.
En Haskell xs ⧺ ys se escribe xs ++ ys.

● ◃ toma una lista xs (a izquierda) y un elemento y devuelve una lista con todos. los
elemento de xs seguidos por x como último elemento. Ej:

```hs
[1, 2] ◃ 3 = [1, 2, 3]
```

Este operador, llamado **pegar a izquierda**, es asociativo a izquierda, luego es lo
mismo ([ ] ◃ z) . . . ◃ y) ◃ x que [ ] ◃ z . . . ◃ y ◃ x.

En Haskell xs ◃ x no está definido, pero podríamos utilizar el operador de **concatenar**
para implementarla de la siguiente manera: xs++[x].
Existen además dos funciones fundamentales sobre listas que listamos a continuación.

● head, llamada **cabeza** o **head** en inglés, toma una lista xs y devuelve su primer
elemento. Ej:

```hs
head.[1,2,3] = 1.
```

● tail, llamada **cola** o **tail** en inglés, toma una lista xs y devuelve la sublista que
resulta de eliminar el primer elemento. Ej:

```hs
tail.[1,2,3] = [2,3]
```
Ejercicio 1: Utilizá las definiciones intuitivas de los operadores de listas para evaluar las
siguientes expresiones. Subrayá la subexpresión resuelta en cada paso justificado. Luego
usá un intérprete de haskell para verificar los resultados. Por ejemplo:

[23, 45, 6] ! (head.[1, 2, 3, 10, 34])

= ```{``` def. de head ```}```

[23, 45, 6] ! 1

= ```{``` def. de ! ```}```

45

***

**a)** length [5,6,7]

= ```{``` def. de length ```}```       

3

***

**b)** [5, 3, 57] !! 1

= ```{``` def. de !! ```}```


3

***

**c)** [0, 11, 2, 5] : [ ]

= ```{``` def. de : ```}```

[0, 11, 2, 5]

***

**d)** take 2 [5, 6, 7]

= ```{``` def. de take ```}```

[5, 6]

***

**e)** drop 2 [5, 6, 7]

= ```{``` def. de drop ```}```

[7]

***

**f)** head (0 : [1, 2, 3])

= ```{``` def. de : ```}```

head [0, 1, 2, 3]

= ```{``` def. de head ```}```

0

***

**g)** ([1, 2] ++ [3, 4]) ++ [2 + 3]        

= ```{``` def. de ++ ```}```

[1, 2, 3, 4] ++ [2 + 3]

= ```{``` def. de ++ ```}```

[1, 2, 3, 4, 5]


## Funciones recursivas

> Una **función recursiva** es una función que se llama a sí misma dentro de su definición.

Una función recursiva es una función tal que en su definición puede aparecer su propio
nombre. Una buena pregunta sería ¿Cómo lograr que no sea una definición circular? La
clave está en el principio de inducción: en primer lugar hay que definir la función para el
(los) caso(s) más “pequeño(s)”, que llamaremos **caso base** y luego definir el caso general
en términos de algo más “chico”, que llamaremos **caso inductivo**. El caso base no debe
aparecer el nombre de la función que se está definiendo. El caso inductivo es donde
aparece el nombre de la función que se está definiendo, y debe garantizarse que el (los)
argumento(s) al cual se aplica en la definición es más “chico” (para alguna definición de más
chico) que el valor para la que se está definiendo.

 Una función de **filter** es aquella que dada una lista devuelve otra lista cuyos elementos son los elementos
de la primera que cumplan una determinada condición, en el mismo orden y con las mismas repeticiones
(si las hubiere). Por ejemplo: $$soloPares : : [Int] -> [Int]$$ devuelve aquellos elementos de la lista que
son pares.

Definí recursivamente las siguientes funciones filter:

**a)** $$soloPares :: [Int] -> [Int]$$, que dada una lista de enteros $$xs$$ devuelve una lista sólo con los
números pares contenidos en $$xs$$, en el mismo orden y con las mismas repeticiones (si las hubiera).

Por ejemplo: $$soloPares [3,0,-2,12] = [0,-2, 12]$$

```hs
soloPares :: [Int] -> [Int]
soloPares [] = []
soloPares (x:xs) | mod x 2 == 0 = x : soloPares xs
                 | mod x 2 /= 0 = soloPares xs
```

En este caso, si el número es par, se agrega a la lista, y si no, se sigue con el siguiente número.

***

**b)** $$mayoresQue10 :: [Int] -> [Int]$$, que dada una lista de enteros xs devuelve una lista sólo con los
números mayores que $$10$$ contenidos en $$xs$$.

Por ejemplo: $$mayoresQue10 [3,0,-2, 12] = [12]$$

```hs
mayoresQue10 :: [Int] -> [Int]
mayoresQue10 [] = []
mayoresQue10 (x:xs) | x > 10 = x : mayoresQue10 xs
                    | x <= 10 = mayoresQue10 xs
```

En este caso, si el número es mayor que $$10$$, se agrega a la lista, y si no, se sigue con el siguiente número.

***

**c)** $$mayoresQue :: Int-> [Int] -> [Int]$$, que dado un entero $$n$$ y una lista de enteros $$xs$$ devuelve
una lista sólo con los números mayores que $$n$$ contenidos en $$xs$$.

Por ejemplo: $$mayoresQue 2 [3,0,-2, 12] = [3,12]$$

```hs
mayoresQue :: Int -> [Int] -> [Int]
mayoresQue n [] = []
mayoresQue n (x:xs) | x > n = x : mayoresQue n xs
                    | x <= n = mayoresQue n xs
```

En este caso, si el número es mayor que $$n$$, se agrega a la lista, y si no, se sigue con el siguiente número.

***

Una función **map** es aquella que dada una lista devuelve otra lista cuyos
elementos son los que se obtienen de aplicar una función a cada elemento de la primera en
el mismo orden y con las mismas repeticiones (si las hubiere). Por ejemplo: $$duplica : [Int] → [Int]$$ 
devuelve cada elemento de la lista multiplicado por $$2$$.

Definí recursivamente las siguientes funciones map:

**a)** $$sumar1: [Int] → [Int]$$, que dada una lista de enteros le suma uno a cada uno de sus
elementos.

 Por ejemplo: $$sumar1.[3, 0, −2] = [4, 1, −1]$$

```hs
sumar1 :: [Int] -> [Int]
sumar1 [] = []
sumar1 (x:xs) = (x + 1) : sumar1 xs
```

En este caso, se suma $$1$$ a cada número de la lista.

***

**b)** $$duplica: [Int] → [Int]$$, que dada una lista de enteros duplica cada uno de sus elementos.

Por ejemplo: $$duplica.[3, 0, −2] = [6, 0, −4]$$

```hs
duplica :: [Int] -> [Int]
duplica [] = []
duplica (x:xs) = (x * 2) : duplica xs
```

En este caso, se duplica cada número de la lista.

***

**c)** $$multiplica: Int → [Int] → [Int]$$, que dado un número n y una lista, multiplica cada uno de los
elementos por $$n$$.

Por ejemplo: $$multiplica.3.[3, 0, −2] = [9, 0, −6]$$

```hs
multiplica :: Int -> [Int] -> [Int]
multiplica n [] = []
multiplica n (x:xs) = (x * n) : multiplica n xs
```

En este caso, se multiplica cada número de la lista por $$n$$.

***

Una función de **fold** es aquella que dada una lista devuelve un valor resultante de combinar los elementos
de la lista. Por ejemplo: $$sum: [Int] -> Int$$ devuelve la sumatoria de los elementos de la lista.

Definí recursivamente las siguientes funciones de tipo fold.

**a)** $$todosMenores10 :: [Int] -> Bool$$, que dada una lista devuelve $$True$$ si ésta consiste sólo de números menores que $$10$$.

Por ejemplo: $$todosMenores10 [1,3,9] = True$$

```hs
todosMenores10 :: [Int] -> Bool
todosMenores10 [] = True
todosMenores10 (x:xs) | x < 10 = todosMenores10 xs
                      | x >= 10 = False
```

En este caso, si todos los números de la lista son menores que $$10$$, se devuelve $$True$$, y si no, $$False$$.

***

**b)** $$hay0 :: [Int] -> Bool$$, que dada una lista decide si existe algún $$0$$ en ella.

Por ejemplo: $$hay0 [1,0,3] = True$$

```hs
hay0 :: [Int] -> Bool
hay0 [] = False
hay0 (x:xs) | x == 0 = True
            | x /= 0 = hay0 xs
```

En este caso, si hay algún $$0$$ en la lista, se devuelve $$True$$, y si no, $$False$$.

***

**c)** $$suma :: [Int] -> Int$$, que dada una lista devuelve la suma de todos sus elementos.

Por ejemplo: $$suma [1,2,3] = 6$$

```hs
suma :: [Int] -> Int
suma [] = 0
suma (x:xs) = x + suma xs
```

En este caso, se devuelve la suma de todos los números de la lista.

***

Una función de tipo **zip** es aquella que dadas dos listas devuelve una lista de pares donde el primer elemento
de cada par se corresponde con la primera lista, y el segundo elemento de cada par se corresponde con
la segunda lista. Por ejemplo: $$repartir :: [String] -> [String] -> [(String,String)]$$ donde los
elementos de la primera lista son nombres de personas y los de la segunda lista son cartas españolas es
una función que devuelve una lista de pares que le asigna a cada persona una carta.

Ej: repartir ["Juan", "Maria"] ["1 de Copa", "3 de Oro", "7 de Espada", "2 de Basto"] =
[("Juan","1 de Copa"), ("Maria","3 de Oro")]

Defina la función recursivamente.

**a)** $$repartir :: [String] -> [String] -> [(String,String)]$$, que dadas dos listas de strings devuelve una lista 
de pares donde el primer elemento de cada par se corresponde con la primera lista, y el segundo elemento de cada par se corresponde con la segunda lista.

```hs  
repartir :: [String] -> [String] -> [(String, String)]
repartir [] [] = []
repartir (x:xs) (y:ys) = (x, y) : repartir xs ys
```

***

Una función de tipo **unzip** es aquella que dada una lista de tuplas devuelve una lista de alguna de las
proyecciones de la tupla. Por ejemplo, si tenemos una lista de ternas donde el primer elemento representa
el nombre de un alumno, el segundo el apellido, y el tercero la edad, la función que devuelve la lista de
todos los apellidos de los alumnos en una de tipo unzip.

Definir la función $$apellidos :: [(String, String, Int)] -> [String]$$.

Ej: apellidos [("Juan","Dominguez",22), ("Maria","Gutierrez",19), ("Damian","Perez",43)]
["Dominguez","Gutierrez","Perez"]


```hs 
apellidos :: [(String, String, Int)] -> [String]
apellidos [] = []
apellidos ((x, y, z):xs) = y : apellidos xs
```

***

Definí funciones por recursión para cada una de las siguientes descripciones.
 (ii) Evaluá los ejemplos manualmente 
 (iii) Identificá si las funciones son de algún tipo ya conocido (filter, map, fold).

 **a)** $$maximo :: [Int] -> Int$$, que calcula el máximo elemento de una lista de enteros.

Por ejemplo: maximo [2,5,1,7,3] = 7

Ayuda: Ir tomando de a dos elementos de la lista y `quedarse' con el mayor.

```hs
maximo :: [Int] -> Int
maximo [x] = x
maximo (x:y:xs) | x > y = maximo (x:xs)
                | x <= y = maximo (y:xs)
```

En este caso, se va comparando el primer número con el segundo, y se va quedando con el mayor. Esta función es de tipo **fold**.

***

**b)** $$sumarPares :: [(Int, Int)] -> [Int]$$, que dada una lista de pares de enteros devuelve una lista con la suma de los elementos de cada par.

Por ejemplo: sumaPares [(1,2)(7,8)(11,0)] = 29

```hs
sumarPares :: [(Int, Int)] -> [Int]
sumarPares [] = []
sumarPares ((x, y):xs) = (x + y) : sumarPares xs
```

En este caso, se va sumando cada par de números. Esta función es de tipo **map**.

***

**c)** $$todos0y1 :: [Int] -> Bool$$, que dada una lista devuelve $$True$$ si ésta consiste sólo de $$0s$$ y $$1s$$.

Por ejemplo: todos0y1 [0,1,0,1] = True

```hs
todos0y1 :: [Int] -> Bool
todos0y1 [] = True
todos0y1 (x:xs) | x == 0 || x == 1 = todos0y1 xs
                | x /= 0 || x /= 1 = False
```

En este caso, se va verificando si los números son $$0$$ o $$1$$. Esta función es de tipo **fold**.

***

**d)** $$quitar0s :: [Int] -> [Int]$$ que dada una lista de enteros devuelve la lista pero quitando todos
los ceros.

Por ejemplo: quitar0s [0,1,0,1] = [1,1]

```hs
quitar0s :: [Int] -> [Int]
quitar0s [] = []
quitar0s (x:xs) | x == 0 = quitar0s xs
                | x /= 0 = x : quitar0s xs
```

En este caso, se va quitando los $$0$$. Esta función es de tipo **filter**.

***

**e)** $$ultimo :: [a] -> a$$, que devuelve el último elemento de una lista.

Por ejemplo: ultimo [10,5,3,1] = 1

```hs
ultimo :: [a] -> a
ultimo [x] = x
ultimo (x:xs) = ultimo xs
```

En este caso, se va recorriendo la lista hasta llegar al último elemento. Esta función es de tipo **fold**.

***

**f)** $$repetir :: Int-> Int-> [Int]$$, que dado un número $$n$$ mayor o igual a $$0$$ y un número $$k$$ arbitrario
construye una lista donde $$k$$ aparece repetido $$n$$ veces.

Por ejemplo: repetir 36 = [6,6,6]

```hs
repetir :: Int -> Int -> [Int]
repetir 0 k = []
repetir n k = k : repetir (n - 1) k
```

En este caso, se va repitiendo el número $$n$$ veces. Esta función es de tipo **map**.

***

**g)** $$concat :: [[a]] -> [a]$$ que toma una lista de listas y devuelve la concatenación de todas ellas.

Por ejemplo: concat [[1,4],[],[2]] = [1,4,2]

```hs
concat :: [[a]] -> [a]
concat [] = []
concat (x:xs) = x ++ concat xs
```

En este caso, se va concatenando cada lista. Esta función es de tipo **fold**.

***

**h)** $$rev :: [a] -> [a]$$ que toma una lista y devuelve una lista con los mismos elementos pero en orden
inverso.

Por ejemplo: rev [1,2,3] = [3,2,1]

```hs
rev :: [a] -> [a]
rev [] = []
rev (x:xs) = rev xs ++ [x]
```
      
En este caso, se va recorriendo la lista en orden inverso. Esta función es de tipo **fold**.

***




 

