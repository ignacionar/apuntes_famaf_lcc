# Especificaciones, Verificaciones y Derivaciones

## Especificaciones y construcción de programas

El proceso de construcción de programas se establece de la siguiente forma: 

<>
  <div style={{ textAlign: "center", margin: "20px auto" }}>
    <p style={{fontWeight: "bold", fontSize: "24px"}}>Problema</p>
    <p>(Impreciso/Informal, poco detallado)</p>
    <p style={{fontSize: "24px"}}>&#8659;</p>
    <p style={{fontWeight: "bold", fontSize: "24px"}}>Especificación</p>
    <p>(Preciso/Formal, poco detallado)</p>
    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr" }}>
      <div>
        <p style={{fontSize: "24px"}}>&#8665;</p>
        <p style={{fontWeight: "bold", fontSize: "24px"}}>Derivación</p>
        <p>(Crear la definición)</p>
        <p style={{fontSize: "24px"}}>&#8664;</p>
      </div>
      <div>
        <p style={{fontSize: "24px"}}>&#8662;</p>
        <p style={{fontWeight: "bold", fontSize: "24px"}}>Verificación</p>
        <p>(Demostrar su validez)</p>
        <p style={{fontSize: "24px"}}>&#8663;</p>
      </div>
    </div>
    <p style={{fontWeight: "bold", fontSize: "24px"}}>Programa</p>
    <p>(Preciso/Formal, detallado)</p>
  </div>
</>

*** 

En programación funcional, un programa consiste en **la definición de funciones y la reducción de expresiones.** 

Podemos resolver problemas a través de funciones, las cuales tendrán la siguiente estructura: 

<div style={{margin: "20px auto", display: "flex", justifyContent: "center" }}>
  <ul style={{ width: "fit-content", textAlign: "left" }}>
    <li style={{ marginBottom: "6px"}}>**1)** Nombre de la función</li>
    <li style={{ marginBottom: "6px"}}>**2)** Tipo de la función (Input / Output)</li>
    <li style={{ marginBottom: "6px"}}>**3)** Predicado que indica **qué debe satisfacer la función** (lo sabremos al derivar).</li>
  </ul>
</div>

Ejemplo: _"quisiera saber si un número es impar..."_

<div style={{margin: "20px auto", display: "flex", justifyContent: "center" }}>
  <ul style={{ width: "fit-content", textAlign: "left" }}>
    <li style={{ marginBottom: "6px"}}>**1)** $esImpar$</li>
    <li style={{ marginBottom: "6px"}}>**2)** $Int \to Bool$</li>
    <li style={{ marginBottom: "6px"}}>**3)** $mod.x.2 \neq 0$</li>
  </ul>
</div>

Nuestro programa sería: 

```math
\begin{array}{l}
  \Big\vert\ esImpar : Int \to Bool \\ 
  \overline{\Big\vert \; esImpar.x \doteq } \; mod.x.2 \neq 0
\end{array}
```

Y también podemos definirlo en Haskell: 
  
```haskell
esImpar :: Int -> Bool
esImpar x = mod x 2 /= 0
```

***

En programación imperativa, un programa es **una secuencia de sentencias que modifican el estado (conjunto de variables con valores) de un sistema.**

Podemos resolver problemas a través de instrucciones, siguiendo esta estructura:

<div style={{margin: "20px auto", display: "flex", justifyContent: "center" }}>
  <ul style={{ width: "fit-content", textAlign: "left" }}>
    <li style={{ marginBottom: "6px"}}>**1)** Constantes</li>
    <li style={{ marginBottom: "6px"}}>**2)** Variables</li>
    <li style={{ marginBottom: "6px"}}>**3)** Precondición</li>
    <li style={{ marginBottom: "6px"}}>**4)** Programa incógnita (S)</li>
    <li style={{ marginBottom: "6px"}}>**5)** Postcondición</li>
  </ul>
</div>

Ejemplo: _"Dado el entero $N > 0$, contar cuántos números entre $0$ y $N$ son múltiplos de $6$..."_

<div style={{margin: "20px auto", display: "flex", justifyContent: "center" }}>
  <ul style={{ width: "fit-content", textAlign: "left" }}>
    <li style={{ marginBottom: "6px"}}>**1)** $\textnormal{Const} \; N : Int;$</li>
    <li style={{ marginBottom: "6px"}}>**2)** $\textnormal{Var} \; resultado : Int ;$</li>
    <li style={{ marginBottom: "6px"}}>**3)** $\{ \; P : N > 0 \; \} $</li>
    <li style={{ marginBottom: "6px"}}>**4)** $S$</li>
    <li style={{ marginBottom: "6px"}}>**5)** $\{ \; Q : resultado = \bigl \langle \textnormal{N} i : 0 \leq i \leq N : i \; mod \; 6 = 0 \; \bigr \rangle \; \} $</li>
  </ul>
</div>

Nuestro programa sería: 

{/* <div style={{ width: "100%", display: "flex"}}> */}
```math 
\begin{aligned}
&\{ \; N > 0 \; \} \\
&numero\_actual, \; resultado := 0, \; 0 \\
&\mathbf{do} \; numero\_actual \leq N \ \rightarrow \\
&\quad \mathbf{if} \; numero\_actual \; mod \; 6 = 0 \rightarrow  \\
&\quad \quad resultado := resultado + 1 \; ; \\
&\quad □ \; numero\_actual \; mod \; 6 \neq 0 \rightarrow \\
&\quad \quad \mathbf{skip} \; ; \\
&\quad \mathbf{fi} \; ; \\
&\quad numero\_actual := numero\_actual + 1 \; ; \\
&\mathbf{od} \; ; \\
&\{ \; numero\_actual = N + 1 \; \land \; resultado = \bigl \langle \textnormal{N} i : 0 \leq i \leq N : i \; mod \; 6 = 0 \; \bigr \rangle \; \}
\end{aligned}
```
{/* </div> */}

(La especificación no declara $numero\_actual$ puesto que es parte del programa final)

Esto puede definirse en C: 

```c
#include <stdio.h>
#define N 5

int main() {
    int numero_actual = 0;
    int resultado = 0;

    do {
        if (numero_actual % 6 == 0) {
            resultado += 1; 
        }         
        numero_actual += 1; 
    } while (numero_actual <= N); 

    printf("Resultado: %d\n", resultado); 

    return 0;
}
```

## Especificaciones (PF)

Suponiendo que sabemos la definición de un programa dado: 

```math
\begin{array}{l}
  \Big\vert\ sum : [Num] \to Num \\
  \overline{\Big\vert \; sum.[] \doteq 0}   \\
  \Big\vert\ sum.(x \triangleright xs) \doteq x + sum.xs
\end{array}
```

Por la definición de la función o por el problema que se nos plantea, podemos escribir una **especificación** mediante una expresión cuantificada: 

```math
sum.xs = \bigl \langle \; \sum i : 0 \leq i < \# xs : xs.i \; \bigr \rangle
```

Ya tenemos una una **descripción formal de la tarea que el programa tiene que realizar**

## Especificaciones (PI)

### Terna de Hoare

> Si tenemos dos predicados $P$ y $Q$, y tenemos una sentencia $S$, podemos preguntarnos si vale o no lo siguiente:\
**"Para todo estado inicial que cumple $P$, la ejecución de $S$ termina en un estado final que satisface $Q$"**, o también, $\; \{ P \} \; S \; \{ Q \}$

Este predicado puede ser True o False, y se denomina <u>Terna de Hoare</u>.

Por ejemplo: 

```math
\begin{aligned}
&\{ \; P: \; x > 0 \; \} \\
&x := x + 1 \\
&\{ \; Q: \; x > 1 \; \}
\end{aligned}
```

En este caso, $\; \{ P \} \; S \; \{ Q \} \equiv True$ , ya que si $x > 0$, entonces $x + 1 > 1$.

El predicado $P$ puede ser **válido para cualquier estado, o puede ser válido para un conjunto de estados**.

El predicado $\{ \; True \; \}$ es válido para cualquier estado, al igual que $\{ \; x > 0 \implies x \geq 0 \; \}$.

$P_0$ es **más fuerte** que $P \iff (P_0 \implies P)$.\
$P_0$ es **más débil** que $P \iff (P \implies P_0)$. 

Podemos pensar en un estado débil si exige menos condiciones para cumplirse, y en un estado fuerte si exige más condiciones.\
Por ejemplo, si $P_0 \equiv \{ \; x > 0 \; \}$ y $P \equiv \{ \; x \geq 0 \; \}$, entonces $P_0$ es más fuerte que $P$.

### Weakest Precondition

Dada la sentencia $S$ y el predicado $Q$, podemos preguntarnos cuál es el predicado más débil que garantiza que $Q$ se cumpla después de ejecutar $S$. Este predicado se llama **Weakest Precondition** y se denota $wp.S.Q$.

La relación entre la Terna de Hoare y la Weakest Precondition es la siguiente: 

```math
\{ P \} \; S \; \{ Q \} \equiv P \implies wp.S.Q
```

## Derivaciones (PF)

Podemos no disponer de la definición de la función, pero sí de una especificación. En este caso, podemos derivar la definición de la función a partir de la especificación.

Por ejemplo, para encontrar el programa de la función $sum$ a partir de la especificación:

```math
sum.xs = \bigl \langle \; \sum i : 0 \leq i < \# xs : xs.i \; \bigr \rangle
```

**Caso base** (cuanto vale $sum.[]$)

```math
\begin{array}{ll}
  sum.[] \\
  \\
  \equiv \{ \textnormal{ Especificación de } sum \; \} \\
  \\
  \bigl \langle \; \sum i : 0 \leq i < \# [] : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \# \; \} \\
  \\
  \bigl \langle \; \sum i : 0 \leq i < 0 : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Aritmética } \} \\
  \\
  \bigl \langle \; \sum i : False : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango vacío } \} \\
  \\
  0
\end{array}
```

Por lo tanto, $sum.[] = 0$

**Paso inductivo** (cuanto vale $sum.(x \triangleright xs)$)

```math
HI : sum.xs = \bigl \langle \; \sum i : 0 \leq i < \# xs : xs.i \; \bigr \rangle
```

```math
\begin{array}{ll}

\underline{sum.(x \triangleright xs)} \\
\\ 
\equiv \{ \textnormal{ Especificación de } sum \; \} \\
\\
\bigl \langle \; \sum i : 0 \leq i < \underline{\# (x \triangleright xs)} : (x \triangleright xs).i \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Definición de } \# \; \} \\
\\
\underline{\bigl \langle \; \sum i : 0 \leq i < 1 + \# xs : (x \triangleright xs).i \; \bigr \rangle \\} \\
\\
\equiv \{ \textnormal{ Separación de un término } \} \\
\\
\underline{(x \triangleright xs).0} + \bigl \langle \; \sum i : 0 \leq i < \# xs : \underline{(x \triangleright xs).(i + 1)} \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Definición de } . \; \} \\
\\
x + \underline{\bigl \langle \; \sum i : 0 \leq i < \# xs : xs.i \; \bigr \rangle} \\
\\
\equiv \{ \textnormal{ Hipótesis inductiva } \} \\
\\
x + sum.xs
\end{array}
```

Por lo tanto, $sum.(x \triangleright xs) = x + sum.xs$

El programa sería:

```math
\begin{array}{l}
  \Big\vert\ sum : [Num] \to Num \\
  \overline{\Big\vert \; sum.[] \doteq 0}   \\
  \Big\vert\ sum.(x \triangleright xs) \doteq x + sum.xs
\end{array}
```

Podemos recurrir a otras técnicas para derivar, estas se encuentran más abajo. 

***

### Análisis por casos

Supongamos que nuestro programa tiene la siguiente especificación: 
  
```math
sum \_ par.n + \bigl \langle \; \sum i : 0 \leq i \leq n \land par.i : i \; \bigr \rangle
```

Y en nuestro paso inductivo $(n + 1)$ llegamos a la siguiente expresión: 

```math
sum \_ par.n + \bigl \langle \; \sum i : i = n + 1 \land par.(n + 1) : i \; \bigr \rangle
```

Observemos que la expresión $par.(n + 1)$ puede ser verdadera o falsa, por lo que debemos analizar ambos casos:

**Caso 1:** $par.(n + 1)$

```math
\begin{array}{ll}
sum \_ par.n + \bigl \langle \; \sum i : i = n + 1 \land \underline{par.(n + 1)} : i \; \bigr \rangle \\
\\
\equiv \{ \; \textnormal{Caso 1:} \; par.(n + 1) \; \} \\
\\
sum \_ par.n + \bigl \langle \; \sum i : i = n + 1 \land True : i \; \bigr \rangle \\
\\
... \\
\\
sum \_ par.n + n + 1
\end{array}
```

**Caso 2:** $\neg par.(n + 1)$

```math
\begin{array}{ll}
sum \_ par.n + \bigl \langle \; \sum i : i = n + 1 \land \underline{par.(n + 1)} : i \; \bigr \rangle \\
\\
\equiv \{ \; \textnormal{Caso 2:} \; \neg par.(n + 1) \; \} \\
\\
sum \_ par.n + \bigl \langle \; \sum i : i = n + 1 \land False : i \; \bigr \rangle \\
\\
... \\ 
\\ 
sum \_ par.n
\end{array}
```

Nuestra definición final sería: 

```math
\begin{array}{l}
  \Big\vert\ sum \_ par : Num \to Num \\ 
  \overline{\Big\vert \; sum \_ par.0 \doteq 0}   \\
  \Big\vert\ sum \_ par.(n + 1) \doteq ( \\
  \Big\vert\ □ \; par.(n+1) → sum \_ par.n + n + 1 \\
  \Big\vert\ □ \; \neg par.(n+1) → sum \_ par.n \\
  \Big\vert\ )
\end{array}
```

***

### Modularización

Supongamos que nuestro programa tiene la siguiente especificación: 

```math
f.x.n = \bigl \langle \; \sum i : 0 \leq i \leq n : x^i \; \bigr \rangle
```

Y en nuestro paso inductivo $(n + 1)$ llegamos a la siguiente expresión: 

```math
f.x.n + \textcolor{darkred}{x^n}
```

La expresión $x^n$ tiene sentido en el lenguaje de la matemática, no de los programas.\
Podemos modularizar la expresión derivando otra función tal que: 

```math
exp.x.n = x^n
```

Tras derivarla obtenemos: 

```math	
\begin{array}{l}
  \Big\vert\ exp : Num \to Num \to Num \\
  \overline{\Big\vert \; exp.x.0 \doteq 1}   \\
  \Big\vert\ exp.x.(n + 1) \doteq n * exp.x.n 
\end{array}
```

Y podemos reemplazar la expresión en nuestra definición: 

```math
\begin{array}{l}
  \Big\vert\ f : Num \to Num \to Num \\
  \overline{\Big\vert \; f.x.0 \doteq x}   \\
  \Big\vert\ f.x.(n + 1) \doteq f.x.n + exp.x.n
\end{array}
```

***

### Generalización

Supongamos que nuestro programa tiene la siguiente especificación: 

```math
psum.xs = \bigl \langle \; \forall i : 0 \leq i < \# xs : sum.(xs↑i) \geq 0 \; \bigr \rangle
```

Al seguir en el paso inductivo $(x \triangleright xs)$, llegamos a la siguiente expresión: 

```math
\begin{array}{ll}
\underline{psum}.(x \triangleright xs) \\
\\
\equiv \{ \textnormal{ Especificación de } psum \} \\
\\
\bigl \langle \; \forall i : 0 \leq i < \underline{\# (x \triangleright xs)} : sum.((x \triangleright xs)↑i) \geq 0 \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Definición de } \# \} \\
\\
\bigl \langle \; \forall i : \underline{0 \leq i < 1 + \# xs} : sum.((x \triangleright xs)↑i) \geq 0 \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Aritmética } \} \\
\\
\bigl \langle \; \forall i : \underline{i = 0 \lor 1 \leq i < \# xs + 1} : sum.((x \triangleright xs)↑i) \geq 0 \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Partición de Rango } \} \\
\\
\underline{\bigl \langle \; \forall i : i = 0 : sum.((x \triangleright xs)↑i) \geq 0 \; \bigr \rangle \; \land \; \bigl \langle \; \forall i : 1 \leq i < \# xs + 1 : sum.((x \triangleright xs)↑i) \geq 0 \; \bigr \rangle} \\
\\
\equiv \{ \textnormal{ Rango unitario, Cambio de Variable: i ← i + 1 } \} \\
\\
sum.((\underline{x \triangleright xs)↑0}) \geq 0 \; \land \; \bigl \langle \; \forall i : 1 \leq i < \# xs + 1 : sum.(\underline{(x \triangleright xs)↑(i + 1)}) \geq 0 \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Definición de } ↑, \textnormal{ Aritmética } \} \\
\\
\underline{sum.[]} \geq 0 \land \bigl \langle \; \forall i : 0 \leq i < \# xs : \underline{sum.((x \triangleright (xs↑i)))} \geq 0 \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Definición de } sum \} \\
\\
\underline{0 \geq 0} \land \bigl \langle \; \forall i : 0 \leq i < \# xs : x + sum.(xs↑i) \geq 0 \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Aritmética, Elemento neutro de } \land \} \\
\\
\bigl \langle \; \forall i : 0 \leq i < \# xs : x + sum.(xs↑i) \geq 0 \; \bigr \rangle
\end{array} 
```

No aplicar nuestra Hipótesis Inductiva, ya que tenemos: 

```math 
\begin{array}{ll}
\bigl \langle \; \forall i : 0 \leq i < \# xs : sum.(xs↑i) \geq 0 \; \bigr \rangle \; (HI) \\
\\
\bigl \langle \; \forall i : 0 \leq i < \# xs : \textcolor{darkred}{x} + sum.(xs↑i) \geq 0 \; \bigr \rangle
\end{array}
```

Podemos generalizar $psum$ definiendo una nueva función $gpsum$, de forma tal que:

```math
gpsum.n.xs = \bigl \langle \; \forall i : 0 \leq i < n : \textcolor{darkred}{n} + sum.(xs↑i) \geq 0 \; \bigr \rangle
```

Podemos decir que $psum.xs = gpsum.0.xs$, ya que: 

```math
\begin{array}{ll}
\underline{gpsum}.0.xs \\
\\
\equiv \{ \textnormal{ Especificación de } gpsum \} \\
\\
\bigl \langle \; \forall i : 0 \leq i < \underline{0} : \underline{0 + sum.(xs↑i)} \geq 0 \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Aritmética } \} \\
\\
\underline{\bigl \langle \; \forall i : 0 \leq i < 0 : sum.(xs↑i) \geq 0 \; \bigr \rangle} \\
\\
\equiv \{ \textnormal{ Especificación de } psum \} \\
\\
psum.xs
\end{array}
```

```math 
\begin{array}{l}
  \Big\vert\ psum : [Num] \to Bool \\
  \overline{\Big\vert \; psum.xs} \doteq gpsum.0.xs 
\end{array}
```

Una vez derivado $gpsum$, tendremos dos programas finales: 

```math 
\begin{array}{l}
  \Big\vert\ gpsum : Num \to [Num] \to Bool \\
  \overline{\Big\vert \; gpsum.n.[]} \doteq ... \\
  \Big\vert\ gpsum.n.(x \triangleright xs) \doteq ...
\end{array}
```

```math 
\begin{array}{l}
  \Big\vert\ psum : [Num] \to Bool \\
  \overline{\Big\vert \; psum.xs} \doteq gpsum.0.xs 
\end{array}
```

***

### Esquemas de Inducción

En algunos casos los esquemas inductivos convencionales no son los necesarios para derivar. 

En el caso de la inducción con naturales, tenemos:

**Inducción Básica:**

```math
f.0 \doteq ? \\
f.(n + 1) \doteq ? 
```

**Inducción a lo Fibonacci:**

```math
fib.0 \doteq 0 \\
fib.1 \doteq 1 \\
fib.(n + 2) \doteq fib.(n + 1) + fib.n
```

En el caso de la inducción con listas, tenemos: 

**Inducción básica:** ($sum$, $prod$, etc.)

```math
f.[] \doteq ? \\
f.(x \triangleright xs) \doteq ?
```

**Inducción con dos o más elementos:** (funciones $iguales$, $minimo$ y $creciente$)

```math
f.[] \doteq ? \\
f.[x] \doteq ? \\
f.(x \triangleright y \triangleright xs) \doteq ?
```

Ejemplo: 

```math 
minimo.xs = \bigl \langle \; \textnormal{Min} \; i : 0 \leq i < \# xs : xs.i \bigr \rangle
```

Si derivamos y el caso base es $[]$ , tendremos como resultado $\infty$.\
Necesitamos reemplazar el caso base por $[x]$ y el Paso inductivo por $(x \triangleright y \triangleright xs)$.

***

### Segmentos de listas

Podemos buscar un **segmento inicial** de una lista derivando la siguiente especificación. 

```math
Q.xs.ys = \bigl \langle \; \exists bs :: ys = xs \textnormal{\;⧺\;} bs \; \bigr \rangle
```

Para derivarlo, nuestro esquema inductivo debe ser el siguiente: 

**Caso Base 1:** ($xs = [], ys$)

**Caso Base 2:** ($xs, ys = []$)

**Paso Inductivo:** ($x \triangleright xs, y \triangleright ys$)

### Ejercicios resueltos - Derivaciones (PF)

**1.** 

Derivar la función $pin8$ a partir de la especificación (donde $prod$ es una función que devuelve el producto de los elementos de una lista):

```math
pin8.xs = \bigl \langle \; \exists as, bs : xs = as \textnormal{\;⧺\;} bs : prod.as = 8 \; \bigr \rangle
```	

Primero evaluamos el caso base, $xs = []$:

```math
\begin{array}{ll}
  \underline{pin8}.[] \\
  \\
  \equiv \{ \textnormal{ Especificación de } pin8 \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{[] = as \textnormal{\;⧺\;} bs} : prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Propiedad de } \textnormal{\;⧺\;} \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{as} = [] \land bs = [] : prod.\underline{as} = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Eliminación de variable } as \; \} \\
  \\
  \bigl \langle \; \exists bs : \underline{bs = []} : prod.[] = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango unitario} \} \\
  \\
  {prod.[]} = 8 \\
  \\
  \equiv \{ \textnormal{ Definición de } prod \; \} \\
  \\
  \underline{1 = 8} \\
  \\
  \equiv \{ \textnormal{ Aritmética } \} \\
  \\
  False
\end{array}
```

Por lo tanto, $pin8.[] = False$

Para el Paso inductivo, seguimos con $xs = (x \triangleright xs)$:

```math
\begin{array}{ll}
  \underline{pin8}.(x \triangleright xs) \\
  \\
  \equiv \{ \textnormal{ Especificación de } pin8 \; \} \\
  \\
  \bigl \langle \; \exists as, bs : (x \triangleright xs) = \underline{as} \textnormal{\;⧺\;} bs : prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Tercero excluido de } as \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{(x \triangleright xs) = as \textnormal{\;⧺\;} bs \land (as = [] \lor as \neq [])} : prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Distributividad de } \land \; \textnormal{con} \; \lor \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{(x \triangleright xs) = as \textnormal{\;⧺\;} bs \land as = [] \lor (x \triangleright xs) = as \textnormal{\;⧺\;} bs \land as \neq []} : prod.as = 8 \; \bigr \rangle \\ 
  \\
  \equiv \{ \textnormal{ Partición de rango, eliminación de variable } as \; \} \\
  \\
  \bigl \langle \; \exists bs : (x \triangleright xs) = \underline{[]} \textnormal{\;⧺\;} bs : prod.[] = 8 \; \bigr \rangle \\ \lor \\ \bigl \langle \; \exists as, bs : (x \triangleright xs) = \underline{as} \textnormal{\;⧺\;} bs : prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \textnormal{⧺}, \textnormal{ Cambio de variable: } as \rightarrow (a \triangleright as) \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{(x \triangleright xs) = bs} : prod.[] = 8 \; \bigr \rangle \\ \lor \\ \bigl \langle \; \exists a, as, bs : \underline{(x \triangleright xs) = (a \triangleright as) \textnormal{\;⧺\;} bs} : prod.(a \triangleright as) = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango unitario, Propiedad de las } [] \; \} \\
  \\
  prod.[] = 8 \; \lor \; \bigl \langle \; \exists a, as, bs : \underline{x = a} \land xs = as \textnormal{\;⧺\;} bs : prod.(a \triangleright as) = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Eliminación de una variable } \} \\
  \\
  prod.[] = 8 \; \lor \; \bigl \langle \; \exists a, as, bs : xs = as \textnormal{\;⧺\;} bs : \underline{prod.(x \triangleright as)} = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } prod \; \} \\
  \\
  prod.[] = 8 \; \lor \; \bigl \langle \; \exists a, as, bs : xs = as \textnormal{\;⧺\;} bs : \textcolor{darkred}{x} * as = 8 \; \bigr \rangle
\end{array}
```

Es necesario generalizar la función $pin8$ para poder derivarla. Definimos una nueva función $gpin8$ tal que:

```math
gpin8.1.xs = \bigl \langle \; \exists as, bs : xs = as \textnormal{\;⧺\;} bs : prod.as = 8 \; \bigr \rangle
```

```math
gpin8.n.xs = \bigl \langle \; \exists as, bs : xs = as \textnormal{\;⧺\;} bs : \textcolor{darkred}{n} * prod.as = 8 \; \bigr \rangle
```

Evaluamos el caso base de $gpin8$:

```math
\begin{array}{ll}
  \underline{gpin8}.n.[] \\
  \\
  \equiv \{ \textnormal{ Especificación de } gpin8 \; \} \\
  \\
  \bigl \langle \; \exists as, bs : [] = as  \textnormal{\;⧺\;} bs : n * prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Propiedad de } ⧺ \} \\
  \\
  \bigl \langle \; \exists \underline{as}, bs : \underline{as} = [] \land bs = [] : n * prod.\underline{as} = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Eliminación de variable } as \; \} \\
  \\
  \bigl \langle \; \exists bs : \underline{[] = bs} : n * prod.[] = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango unitario } \} \\
  \\
  n * \underline{prod.[]} = 8 \\
  \\
  \equiv \{ \textnormal{ Definición de } prod \; \} \\
  \\
  \underline{n * 1} = 8 \\
  \\
  \equiv \{ \textnormal{ Aritmética } \} \\
  \\
  n = 8
\end{array}
```

Seguimos con el paso inductivo de $gpin8$:

```math
\begin{array}{ll}
  \underline{gpin8}.n.(x \triangleright xs) \\
  \\
  \equiv \{ \textnormal{ Especificación de } gpin8 \; \} \\
  \\
  \bigl \langle \; \exists as, bs : (x \triangleright xs) = \underline{as} \textnormal{\;⧺\;} bs : n * prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Tercero excluido de } as \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{(x \triangleright xs) = as \textnormal{\;⧺\;} bs \land (as = [] \lor as \neq [])} : n * prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Distributividad de } \land \; \textnormal{con} \; \lor \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{(x \triangleright xs) = as \textnormal{\;⧺\;} bs \land as = [] \lor (x \triangleright xs) = as \textnormal{\;⧺\;} bs \land as \neq []} : n * prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Partición de rango, eliminación de variable } as \; \} \\
  \\
  \bigl \langle \; \exists bs : (x \triangleright xs) = \underline{[]} \textnormal{\;⧺\;} bs : n * prod.[] = 8 \; \bigr \rangle \\ \lor \\ \bigl \langle \; \exists as, bs : (x \triangleright xs) = \underline{as} \textnormal{\;⧺\;} bs : n * prod.as = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \textnormal{⧺}, \textnormal{ Cambio de variable: } as \rightarrow (a \triangleright as) \; \} \\
  \\
  \bigl \langle \; \exists as, bs : \underline{(x \triangleright xs) = bs} : n * prod.[] = 8 \; \bigr \rangle \\ \lor \\ \bigl \langle \; \exists a, as, bs : \underline{(x \triangleright xs) = (a \triangleright as) \textnormal{\;⧺\;} bs} : n * prod.(a \triangleright as) = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango unitario, Propiedad de las } [] \; \} \\
  \\
  n * prod.[] = 8 \; \lor \; \bigl \langle \; \exists \underline{a}, as, bs : \underline{x = a} \land xs = as \textnormal{\;⧺\;} bs : n * prod.(\underline{a} \triangleright as) = 8 \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Eliminación de variable } a \; \} \\
  \\
  n * \underline{prod.[]} = 8 \; \lor \; \bigl \langle \; \exists as, bs : xs = as \textnormal{\;⧺\;} bs : \underline{n * prod.(x \triangleright as) = 8} \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } prod \; \} \\
  \\
  \underline{n * 1} = 8 \; \lor \; \underline{\bigl \langle \; \exists as, bs : xs = as \textnormal{\;⧺\;} bs : n * x * prod.as = 8 \; \bigr \rangle} \\
  \\
  \equiv \{ \textnormal{ Aritmética, hipótesis inductiva con } n = (n * x) \} \\
  \\
  n = 8 \; \lor \; gpin8.(n * x).xs
\end{array}
```

Los programas son: 

```math
\begin{array}{l}
  \Big\vert\ pin8 : [Num] \to Bool \\  
  \overline{\Big\vert\ pin8.(x \triangleright xs)} \doteq gpin8.1.(x \triangleright xs)
\end{array}
```

```math
\begin{array}{l}
  \Big\vert\ gpin8 : Num \to [Num] \to Bool \\
  \overline{\Big\vert \; gpin8.n.xs} \doteq n = 8 \\
  \Big\vert\ gpin8.n.(x \triangleright xs) \doteq n = 8 \; \lor \; gpin8.(n * x).xs
\end{array}
```

***

**2.**

Derivar la función $minimo$ a partir de la especificación: 

```math
minimo.xs = \bigl \langle \; \textnormal{Min} \; i : 0 \leq i < \# xs : xs.i \; \bigr \rangle
```

Primero evaluamos el caso base, $xs = []$:

```math
\begin{array}{ll}
  \underline{minimo}.[] \\
  \\
  \equiv \{ \textnormal{ Especificación de } minimo \; \} \\
  \\
  \bigl \langle \; \textnormal{Min} \; i : 0 \leq i < \underline{\# []} : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \# \; \} \\
  \\
  \bigl \langle \; \textnormal{Min} \; i : \underline{0 \leq i < 0} : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Aritmética } \} \\
  \\
  \bigl \langle \; \textnormal{Min} \; i : \underline{False} : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango vacío } \} \\
  \\
  +\infty
\end{array}
```

No podemos computar $+\infty$, por lo que necesitamos cambiar nuestro esquema inductivo. Nuestra lista vacía no puede ser evaluada, por lo que necesitamos evaluar $[x]$.

```math 
\begin{array}{ll}
  \underline{minimo}.[x] \\
  \\
  \equiv \{ \textnormal{ Especificación de } minimo \; \} \\
  \\
  \bigl \langle \; \textnormal{Min} \; i : 0 \leq i < \underline{\# [x]} : [x].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \# \; \} \\
  \\
  \bigl \langle \; \textnormal{Min} \; i : \underline{0 \leq i < 1} : [x].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Lógica } \} \\
  \\
  \bigl \langle \; \textnormal{Min} \; i : i = 0 : [x].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango unitario } \} \\
  \\
  x
\end{array}
```

Ahora seguimos con el paso inductivo $xs = (x \triangleright y \triangleright xs)$:

```math
\begin{array}{ll}
  \underline{minimo}.(x \triangleright y \triangleright xs) \\
  \\
  \equiv \{ \textnormal{ Especificación de } minimo \; \} \\
  \\
  \bigl \langle \; \textnormal{Min} \; i : 0 \leq i < \underline{\# (x \triangleright y \triangleright xs)} : (x \triangleright y \triangleright xs).i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \# \; \} \\
  \\
  \underline{ \bigl \langle \; \textnormal{Min} \; i : 0 \leq i < 1 + \# (y \triangleright xs) : (x \triangleright y \triangleright xs).i \; \bigr \rangle} \\
  \\
  \equiv \{ \textnormal{ Separación de un término } \} \\
  \\
  \underline{(x \triangleright y \triangleright xs).0} + \bigl \langle \; \textnormal{Min} \; i : 0 \leq i < \# (y \triangleright xs) : \underline{(x \triangleright y \triangleright xs).(i + 1)} \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } . \; \} \\
  \\
  x \; \textnormal{min} \; \underline{\bigl \langle \; \textnormal{Min} \; i : 0 \leq i < \# (y \triangleright xs) : (y \triangleright xs).i \; \bigr \rangle} \\
  \\
  \equiv \{ \textnormal{ Hipótesis Inductiva con } (y \triangleright xs) \} \\
  \\
  x \; \textnormal{min} \; minimo.(y \triangleright xs)
\end{array}
```

Nuestro programa final sería: 

```math
\begin{array}{l}
  \Big\vert\ minimo : [Num] \to Num \\
  \overline{\Big\vert \; minimo.[x] \doteq x}   \\
  \Big\vert\ minimo.(x \triangleright y \triangleright xs) \doteq x \; \textnormal{min} \; minimo.(y \triangleright xs)
\end{array}
```

## Derivaciones (PI)

A través de una especificación dada como una terna: 

```math 
\{\; P \; \} \\ 
S \\
\{\; Q \; \}
```
Podemos derivar el programa incógnita $S$ con la precondición $P$ y la postcondición $Q$ dadas.\
Para ello recurrimos a los predicados asociados a la Terna o a la definición de Weakest Precondition. De manera tal que se cumpla que $P \implies Q$.

### _Skip_ 

Si tenemos una especificación de la forma: 

```math
\begin{aligned}
&\textnormal{Const} \; N : Int, \; A : array[p, q)ofInt; \\
&\textnormal{Var} \; pos, \; i : Int; \\
&\{ \; P: res=0 \land pos = 0 \; \} \\
&S \\
&\{ \; res = \bigl \langle \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \; \}
\end{aligned}
```

Podemos determinar si $S$ es un $\mathbf{skip}$ suponiendo $P$ y partiendo de la postcondición $Q$:

```math
\begin{array}{ll}
  \underline{Q} \\
  \\
  \equiv \{ \textnormal{ Definición de } Q \; \} \\
  \\
  \underline{res} = \bigl \langle \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Hipótesis de } P \; \} \\
  \\
  0 = \bigl \langle \sum i : \underline{0 \leq i \leq 0} : A.i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango vacío } \} \\
  \\
  \textnormal{0 = 0} \\
  \\
  \equiv \{ \textnormal{ Lógica } \} \\
  \\
  True
\end{array}
```

En este caso sencillo, podemos determinar que $S$ es un $\mathbf{skip}$, ya que $P \implies Q$ sin necesidad de ejecutar ninguna sentencia:

```math
\begin{aligned}
&\textnormal{Const} \; A : array[p, q)ofInt; \\
&\textnormal{Var} \; res, \; pos : Int; \\
&\{ \; P: res=0 \land pos = 0 \; \} \\
&\mathbf{skip}; \\
&\{ \; res = \bigl \langle \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \; \}
\end{aligned}
```

***

### Asignación 

Supongamos que $S$ no es un skip ($P$ no implica $Q$) podemos probar tomando las variables del programa y asignarlas a incógnitas. 

Tomemos el siguiente ejemplo:
  
```math
\begin{aligned}
&\textnormal{Const} \; A : array[p, q)ofInt; \\
&\textnormal{Var} \; res, \; pos : Int; \\
&\{ \; P: \bigl \langle \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \land 0 \leq pos < N \; \} \\
&S \\
&\{ \; res = \bigl \langle \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \; \}
\end{aligned}
```

Por intuición sabemos que $pos$ puede ser $pos + 1$. Sin embargo, debemos determinar el valor de $res$. Podemos probar asignar $res$ a una incógnita $E$ y usar la definición de Weakest Precondition:

```math
P \implies wp.(res, \; pos := E, \; pos + 1).(res = \bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle) \\
\; \\
\begin{aligned}
&\underline{wp.(res, \; pos := E, \; pos + 1).(res = \bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle)} \\ 
\\
&\equiv \{ \textnormal{ Definición de wp para } := \; \} \\
\\
&E = \bigl \langle \; \sum i : \underline{0 \leq i \leq pos + 1} : A.i \; \bigr \rangle \\ 
\\ 
&\equiv \{ \textnormal{ Lógica } \; \} \\
\\
&E = \bigl \langle \; \sum i : \underline{0 \leq i \leq pos \lor i = pos } : A.i \; \bigr \rangle \\ 
\\
&\equiv \{ \textnormal{ Partición de Rango } \} \\
\\
&E = \underline{\bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle} + \bigl \langle \; \sum i : i = pos : A.i \; \bigr \rangle \\
\\
&\equiv \{ \textnormal{ Hipótesis de } res \; \} \\
\\
&E = res + \underline{\bigl \langle \; \sum i : i = pos : A.i \; \bigr \rangle} \\
\\ 
&\equiv \{ \textnormal{ Rango unitario } \} \\
\\
&\underline{E = res + A.pos} \\ 
\\
&\equiv \{ \textnormal{ Elijo } E = res + A.pos \; \} \\
\\
&True
\end{aligned}
```

Entonces nuestro programa queda:

```math
\begin{aligned}
&\textnormal{Const} \; A : array[p, q)ofInt; \\
&\textnormal{Var} \; res, \; pos : Int; \\
&\{ \; P: \bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \land 0 \leq pos < N \; \} \\
&res, \; pos := res + A.pos, \; pos + 1; \\
&\{ \; res = \bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \; \}
\end{aligned}
```

*** 

### Condicional 

Si por ejemplo quisieramos saber el máximo entre dos números sin usar el operador $\textnormal{max}$, debemos descubrir la sentencia $S$ de:

```math
\begin{aligned}
&\textnormal{Var} \; x, \; y, \; res : Int; \\
&\{ \; P: x = X \land y = Y \} \\
&S \\
&\{ \; res = X \; \textnormal{max} \; Y \; \}
\end{aligned}
```

(Tanto $X$ como $Y$ son variables de especificación)

No debemos usar $\mathbf{skip}$, pero podemos probar asignando $res$ a una variable incógnita $E$ y aplicar la definición de Weakest Precondition:

```math
P \implies wp.(res := E).(res = X \; \textnormal{max} \; Y) \\
\; \\
\begin{aligned}
&\underline{wp.(res := E).(res = X \; \textnormal{max} \; Y)} \\
\\ 
&\equiv \{ \textnormal{ Definición de wp para } := \; \} \\
\\
&E = X \; \textnormal{max} \; Y 
\end{aligned} 
```

Siguiendo el enunciado no podemos usar el operador $\textnormal{max}$, podemos resolver esto mediante un análisis por casos:

**Caso 1:** $x \geq y$

```math
\begin{aligned}
&E = \underline{X \; \textnormal{max} \; Y} \\ 
\\
&\equiv \{ \textnormal{ Hipótesis de } P \; \} \\
\\
&E = \underline{x \; \textnormal{max} \; y} \\
\\
&\equiv \{ \textnormal{ Caso 1: } x \geq y \; \} \\
\\
&\underline{E = x} \\
\\
&\equiv \{ \textnormal{ Elijo } E = x \; \} \\
\\
&True
\end{aligned} 
```

**Caso 2:** $x \leq y$

```math
\begin{aligned}
&E = \underline{X \; \textnormal{max} \; Y} \\ 
\\
&\equiv \{ \textnormal{ Hipótesis de } P \; \} \\
\\
&E = \underline{x \; \textnormal{max} \; y} \\
\\
&\equiv \{ \textnormal{ Caso 2: } x \leq y \; \} \\
\\
&\underline{E = y} \\
\\
&\equiv \{ \textnormal{ Elijo } E = y \; \} \\
\\
&True
\end{aligned} 
```

Derivando la asignación, llegamos a un análisis por casos, por lo que podemos usar $\mathbf{if}$, donde cada caso es una guarda para determinar el programa final:

```math 
\begin{aligned}
&\textnormal{Var} \; x, \; y, \; res : Int; \\
&\{ \; P: x = X \land y = Y \} \\
&\mathbf{if} \; x \geq y \rightarrow \\
&\quad res := x; \\
&□ \; x \leq y \rightarrow \\
&\quad res := y; \\
&\mathbf{fi}; \\
&\{ \; res = X \; \textnormal{max} \; Y \; \}
\end{aligned}
```

Cuando se utiliza el cuantificador de conteo $\textnormal{N}$ en una especificación, se puede terminar en un análisis por casos si se utiliza el rango unitario: 

Por ejemplo:

```math 
\begin{aligned}
&... \\
&E = res + \bigl \langle \; \textnormal{N} i : \underline{i = numero\_actual} : i \; \textnormal{mod} \; 6 = 0 \; \bigr \rangle \\
\\ 
&\equiv \{ \textnormal{ Rango unitario } \} \\
\\
&E = res + ( \\
& numero\_actual \; \textnormal{mod} \; 6 = 0 \rightarrow 1 \\
& □ \; numero\_actual \; \textnormal{mod} \; 6 \neq 0 \rightarrow 0 \\
&)
\end{aligned}
```

Tendríamos las dos posibilidades de que la variable $numero\_actual$ sea múltiplo de 6 o no.

*** 

### Secuenciación

Muchas veces tenemos un problema principal y otro problema accesorio que resolver.\
Por ejemplo, la siguiente especificación:

```math 
\begin{aligned}
&\textnormal{Const} \; N : Int, \; A : array[0,N) of Int; \\
&\textnormal{Var} \; promedio : Float; \\
&\{ P: \; N > 0 \; \} \\
&S \\
&\{ Q: \; promedio = \bigl \langle \; \sum i : 0 \leq i \leq N : A.i \; \bigr \rangle \; / \; N \; \}
\end{aligned}
```

Primero podemos resolver el problema principal (sumar todos los elementos), y dividirlos por $N$ (problema accesorio).\
Cambiando un poco la estructura y agregando una variable $suma$ sería:

```math 
\begin{aligned}
&\textnormal{Const} \; N : Int, \; A : array[0,N) of Int; \\
&\textnormal{Var} \; promedio : Float, \; suma : Int; \\
&\{ P: \; N > 0 \; \} \\
&S_1; \\
&\{ Q: \; suma = \bigl \langle \; \sum i : 0 \leq i \leq N : A.i \; \bigr \rangle \; \} \\
&S_2; \\
&\{ R: \; promedio = \bigl \langle \; \sum i : 0 \leq i \leq N : A.i \; \bigr \rangle \; / \; N \; \}
\end{aligned}
```

Una vez realizado el trabajo de derivación en $S_1$ y $S_2$, daremos con el programa final.

***

### Repetición 

Las repeticiones serán necesarias cuando necesitemos ejecutar una misma acción varias veces.\
Por ejemplo, si queremos sumar los elementos de un arreglo, necesitaremos recorrerlo. 

```math
\begin{aligned}
&\textnormal{Const} \; N : Int, \; A : array[0,N) of Int; \\
&\textnormal{Var} \; res, \; i : Int; \\
&\{ P: \; N > 0 \; \} \\
&S \\
&\{ Q: \; res = \bigl \langle \; \sum i : 0 \leq i \leq N : A.i \; \bigr \rangle \; \}
\end{aligned}
```

Para poder determinar la **inicialización** y el **cuerpo de ciclo**, necesitamos primero proponer una **invariante** y la **guarda**. 

El invariante debe cumplir las siguientes condiciones: 

- **1)** $P \implies I \;$ (El invariante debe ser verdadero al inicio)

- **2)** $\{I \land B\} \; S \; \{I\} \;$ (El cuerpo de ciclo mantiene el invariante)

- **3)** $I \land \neg B \implies Q \;$ (El invariante implica la postcondición al terminar el ciclo)

- **4)** El ciclo debe terminar

El problema surge en como determinar el invariante. Para ello podemos hacer un **reemplazo de constante por variable**

Podemos reemplazar la constante $N$ por una variable $pos$, y proponer un invariante $I$:

```math
I \equiv res = \bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \land 0 \leq pos \leq N
```

Determinamos que $pos$ debe ser menor o igual a $N$ para no exceder el rango del arreglo.

Una guarda $B$ puede ser $pos < N$, ya que queremos recorrer todos los elementos del arreglo. 

En base a las condiciones anteriores de invariante y guarda, podemos proponer un ciclo:

```math
\begin{aligned}
&\textnormal{Const} \; N : Int, \; A : array[0,N) of Int; \\
&\textnormal{Var} \; res, \; pos : Int; \\
&\{ \; P: \; N > 0 \; \} \\
&S_1; \\
&\{ \; I \; \} \\
&\mathbf{do} \; pos < N \rightarrow \\
&\quad \{ \; I \land B \; \} \\
&\quad S_2; \\
&\quad \{ \; I \; \} \\
&\mathbf{do}; \\
&\{ \; Q: \; res = \bigl \langle \; \sum i : 0 \leq i \leq N : A.i \; \bigr \rangle \; \}
\end{aligned}
```

Donde $S_1$ es la inicialización y $S_2$ es el cuerpo del ciclo. Ahora podemos derivar ambos para llegar al programa final.

Para $S_1$, podemos probar con $pos, \; res := 0, \; E$, la posición a indexar será por defecto $0$:

```math
P \implies wp.(pos, \; res := 0, \; E).I \\
\; \\
\begin{array}{ll}
\underline{wp.(pos, \; res := 0, \; E).(res = \bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \land 0 \leq pos \leq N)} \\
\\ 
\equiv \{ \textnormal{ Definición de wp para } := \; \} \\
\\
E = \bigl \langle \; \sum i : 0 \leq i \leq 0 : A.i \; \bigr \rangle \; \underline{\land \; 0 \leq 0 \leq N} \\
\\
\equiv \{ \textnormal{ Hipótesis de } P, \textnormal{ elemento neutro de} \; \land \; \} \\
\\
E = \bigl \langle \; \sum i : \underline{0 \leq i \leq 0} : A.i \; \bigr \rangle \\ 
\\
\equiv \{ \textnormal{ Rango vacío } \} \\
\\
\underline{E = 0} \\
\\
\equiv \{ \textnormal{ Elijo } E = 0 \; \} \\
\\
True
\end{array} 
```

Tenemos que $S_1: pos, \; res := 0, \; 0$. Ahora podemos derivar $S_2$ probando con $pos, \; res := pos + 1, \; E$, queremos aumentar la posición a indexar:

```math
P \implies wp.(pos, \; res := pos + 1, \; E).I \\
\; \\
\begin{array}{ll}
\underline{wp.(pos, \; res := pos + 1, \; E).(res = \bigl \langle \; \sum i : 0 \leq i \leq pos : A.i \; \bigr \rangle \land 0 \leq pos \leq N)} \\
\\
\equiv \{ \textnormal{ Definición de wp para } := \; \} \\
\\
E = \bigl \langle \; \sum i : 0 \leq i \leq pos + 1 : A.i \; \bigr \rangle \; \underline{\land \; 0 \leq pos + 1 \leq N} \\
\\
\equiv \{ \textnormal{ Validez por hipótesis } 0 \leq pos \land pos < N, \textnormal{ elemento neutro de } \; \land \; \} \\
\\
E = \bigl \langle \; \sum i : \underline{0 \leq i \leq pos + 1} : A.i \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Lógica } \} \\
\\
E = \bigl \langle \; \sum i : \underline{0 \leq i < pos \lor i = pos} : A.i \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Partición de Rango } \} \\
\\
E = \underline{\bigl \langle \; \sum i : 0 \leq i < pos : A.i \; \bigr \rangle} + \bigl \langle \; \sum i : i = pos : A.i \; \bigr \rangle \\
\\
\equiv \{ \textnormal{ Hipótesis de } res \; \} \\
\\
E = res + \underline{\bigl \langle \; \sum i : i = pos : A.i \; \bigr \rangle} \\
\\
\equiv \{ \textnormal{ Rango unitario } \} \\
\\
\underline{E = res + A.pos} \\
\\
\equiv \{ \textnormal{ Elijo } E = res + A.pos \; \} \\
\\
True
\end{array} 
```

Por lo tanto, $S_2: pos, \; res := pos + 1, \; res + A.pos$. Ahora podemos dar con el programa final:

```math
\begin{aligned}
&\textnormal{Const} \; N : Int, \; A : array[0,N) of Int; \\
&\textnormal{Var} \; res, \; pos : Int; \\
&\{ \; P: \; N > 0 \; \} \\
&pos, \; res := 0, \; 0; \\
&\mathbf{do} \; pos < N \rightarrow \\
&\quad pos, \; res := pos + 1, \; res + A.pos; \\
&\mathbf{do}; \\
&\{ \; Q: \; res = \bigl \langle \; \sum i : 0 \leq i \leq N : A.i \; \bigr \rangle \; \}
\end{aligned}
```

### Ejercicios resueltos - Derivaciones (PI)

## Verificación (PF)

Podemos demostrar que $\bigl \langle \forall xs :: P.xs \bigr \rangle$

Cumple con:

```math
P.xs : sum.xs = \bigl \langle \; \sum i : 0 \leq i < \# xs : xs.i \; \bigr \rangle
```

Para lograrlo podemos utilizar inducción matemática o inducción estructural sobre listas (en este caso, la segunda):

**Caso base:**  ($xs = []$)

Debemos demostrar que: 

```math
P.[] : sum.[] = \bigl \langle \; \sum i : 0 \leq i < \# [] : [].i \; \bigr \rangle
```

Para ello podemos comenzar del lado derecho: 

```math
\begin{array}{ll}
  \bigl \langle \; \sum i : 0 \leq i < \underline{\#[]} : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \# \; \} \\
  \\
  \bigl \langle \; \sum i : \underline{0 \leq i < 0} : [].i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Aritmética } \} \\
  \\
  \bigl \langle \; \underline{\sum i : False : [].i} \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Rango vacío } \} \\
  \\
  0 \\
  \\
  \equiv \{ \textnormal{ Definición de } sum\; \} \\
  \\
  sum.[]
\end{array}
```

Por lo tanto, probamos la propiedad $P.[]$

**Paso inductivo:** ($x \triangleright xs$)

Debemos demostrar que: 

```math
\begin{array}{ll}
P.xs : sum.xs = \bigl \langle \; \sum i : 0 \leq i < \# xs : xs.i \; \bigr \rangle \implies \\
\\
P.(x \triangleright xs) : sum.(x \triangleright xs) = \bigl \langle \; \sum i : 0 \leq i < \# (x \triangleright xs) : (x \triangleright xs).i \; \bigr \rangle
\end{array}
```	

Donde $P.xs$ es la **hipótesis inductiva**.

Para ello podemos comenzar del lado derecho:

```math
\begin{array}{ll}
  \bigl \langle \; \sum i : 0 \leq i < \underline{ \# (x \triangleright xs) } : (x \triangleright xs).i \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } \# \; \} \\
  \\
  \bigl \langle \; \underline{ \sum i : 0 \leq i < 1 + \# xs : (x \triangleright xs).i } \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Separación de un término } \} \\
  \\
  \underline{ (x \triangleright xs).0 } + \bigl \langle \; \sum i : 0 \leq i < \# xs : \underline{(x \triangleright xs).(i + 1)} \; \bigr \rangle \\
  \\
  \equiv \{ \textnormal{ Definición de } .\; \} \\
  \\
  x + \underline{\bigl \langle \; \sum i : 0 \leq i < \# xs : xs.i \; \bigr \rangle} \\
  \\
  \equiv \{ \textnormal{ Hipótesis inductiva } \} \\
  \\
  x + sum.xs 
\end{array}
```

Por lo tanto, probamos la propiedad $P.(x \triangleright xs)$, y su validez en cualquier lista.

{/* ## Verificación (PI) */}

